// lib/services/employeur_service.dart
import 'package:supabase_flutter/supabase_flutter.dart';

/// Service Employeur prÃ©Â©Ã†â€™Âªt pour prod.
/// SchÃ©Â©Ã†â€™Â©ma attendu:
/// - Table public.employeurs { id uuid PK, proprietaire uuid FK->auth.users, nom text, ... }
/// - Index unique: CREATE UNIQUE INDEX ON public.employeurs(proprietaire);
/// - RLS: SELECT/INSERT/UPDATE pour authenticated oÃ©Â©Ã†â€™Â¹ proprietaire = auth.uid()
class EmployeurService {
  EmployeurService({SupabaseClient? client})
      : _sb = client ?? Supabase.instance.client;

  final SupabaseClient _sb;

  String _currentUserIdOrThrow() {
    final uid = _sb.auth.currentUser?.id;
    if (uid == null) throw StateError('Utilisateur non connectÃ©Â©Ã†â€™Â©');
    return uid;
  }

  // Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬ Lecture Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬

  /// ID de l'employeur de l'utilisateur courant (ou null).
  Future<String?> getEmployeurId() async {
    try {
      final uid = _currentUserIdOrThrow();
      final row = await _sb
          .from('employeurs')
          .select('id')
          .eq('proprietaire', uid)
          .maybeSingle();
      return row == null ? null : (row['id'] as String);
    } on PostgrestException catch (e) {
      throw Exception(e.message ?? 'Erreur base de donnÃ©Â©Ã†â€™Â©es');
    }
  }

  /// Ligne employeur complÃ©Â©Ã†â€™Â¨te (ou null).
  Future<Map<String, dynamic>?> getEmployeurRow() async {
    try {
      final uid = _currentUserIdOrThrow();
      final row = await _sb
          .from('employeurs')
          .select() // <- pas de gÃ©Â©Ã†â€™Â©nÃ©Â©Ã†â€™Â©rique
          .eq('proprietaire', uid)
          .maybeSingle();
      return row == null ? null : Map<String, dynamic>.from(row as Map);
    } on PostgrestException catch (e) {
      throw Exception(e.message ?? 'Erreur base de donnÃ©Â©Ã†â€™Â©es');
    }
  }

  Future<bool> isEmployeur() async => (await getEmployeurId()) != null;

  // Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬ CrÃ©Â©Ã†â€™Â©ation / Upsert Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬

  /// CrÃ©Â©Ã†â€™Â©e (si absent) ou rÃ©Â©Ã†â€™Â©cupÃ©Â©Ã†â€™Â¨re l'employeur, et retourne son **id**.
  Future<String> ensureEmployeurId({
    required String nom,
    String? telephone,
    String? email,
    String? ville,
    String? commune,
    String? secteur,
  }) async {
    try {
      final uid = _currentUserIdOrThrow();

      final exist = await getEmployeurId();
      if (exist != null) return exist;

      final payload = <String, dynamic>{
        'proprietaire': uid,
        'nom': nom,
        if (telephone != null && telephone.trim().isNotEmpty)
          'telephone': telephone.trim(),
        if (email != null && email.trim().isNotEmpty) 'email': email.trim(),
        if (ville != null && ville.trim().isNotEmpty) 'ville': ville.trim(),
        if (commune != null && commune.trim().isNotEmpty)
          'commune': commune.trim(),
        if (secteur != null && secteur.trim().isNotEmpty)
          'secteur': secteur.trim(),
      };

      final row = await _sb
          .from('employeurs')
          .upsert(payload, onConflict: 'proprietaire')
          .select('id')
          .single(); // renvoie l'id mÃ©Â©Ã†â€™Âªme si update

      return row['id'] as String;
    } on PostgrestException catch (e) {
      throw Exception(e.message ?? 'Erreur base de donnÃ©Â©Ã†â€™Â©es');
    }
  }

  /// Upsert et renvoie la ligne complÃ©Â©Ã†â€™Â¨te.
  Future<Map<String, dynamic>> upsertEmployeur({
    required String nom,
    String? telephone,
    String? email,
    String? ville,
    String? commune,
    String? secteur,
  }) async {
    try {
      final uid = _currentUserIdOrThrow();
      final payload = <String, dynamic>{
        'proprietaire': uid,
        'nom': nom,
        if (telephone != null && telephone.trim().isNotEmpty)
          'telephone': telephone.trim(),
        if (email != null && email.trim().isNotEmpty) 'email': email.trim(),
        if (ville != null && ville.trim().isNotEmpty) 'ville': ville.trim(),
        if (commune != null && commune.trim().isNotEmpty)
          'commune': commune.trim(),
        if (secteur != null && secteur.trim().isNotEmpty)
          'secteur': secteur.trim(),
      };

      final row = await _sb
          .from('employeurs')
          .upsert(payload, onConflict: 'proprietaire')
          .select() // <- pas de gÃ©Â©Ã†â€™Â©nÃ©Â©Ã†â€™Â©rique
          .single();

      return Map<String, dynamic>.from(row as Map);
    } on PostgrestException catch (e) {
      throw Exception(e.message ?? 'Erreur base de donnÃ©Â©Ã†â€™Â©es');
    }
  }

  // Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬ Mise Ã©Â©Ã†â€™  jour partielle Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬Ã©Â©Â¢â€šÂ¬Ââ‚¬Å¡Â¬

  /// Met Ã©Â©Ã†â€™  jour des champs de l'employeur et renvoie la ligne.
  Future<Map<String, dynamic>> updateEmployeur(
      Map<String, dynamic> changes) async {
    if (changes.isEmpty) {
      throw ArgumentError('Aucun champ Ã©Â©Ã†â€™  mettre Ã©Â©Ã†â€™  jour');
    }
    try {
      final uid = _currentUserIdOrThrow();
      final row = await _sb
          .from('employeurs')
          .update(changes)
          .eq('proprietaire', uid)
          .select() // <- pas de gÃ©Â©Ã†â€™Â©nÃ©Â©Ã†â€™Â©rique
          .single();

      return Map<String, dynamic>.from(row as Map);
    } on PostgrestException catch (e) {
      throw Exception(e.message ?? 'Erreur base de donnÃ©Â©Ã†â€™Â©es');
    }
  }

  // Helpers pratiques
  Future<Map<String, dynamic>> updateNom(String nom) =>
      updateEmployeur({'nom': nom});

  Future<Map<String, dynamic>> updateCoordonnees({
    String? telephone,
    String? email,
    String? ville,
    String? commune,
  }) =>
      updateEmployeur({
        if (telephone != null) 'telephone': telephone,
        if (email != null) 'email': email,
        if (ville != null) 'ville': ville,
        if (commune != null) 'commune': commune,
      });

  /// S'assure qu'un employeur existe (crÃ©Â©Ã†â€™Â©ation si besoin) et renvoie son id.
  Future<String> assertEmployeurExists({required String nomParDefaut}) =>
      ensureEmployeurId(nom: nomParDefaut);
}
