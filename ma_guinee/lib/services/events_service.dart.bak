import 'package:supabase_flutter/supabase_flutter.dart';

class EventsService {
  final SupabaseClient _sb = Supabase.instance.client;

  String _requireUserId() {
    final user = _sb.auth.currentUser;
    if (user == null) {
      throw StateError('Utilisateur non connectÃ©Â©Ã†â€™Â©.');
    }
    return user.id;
  }

  Future<List<Map<String, dynamic>>> fetchEvents(
      {bool onlyPublished = true}) async {
    // Construire la requÃ©Â©Ã†â€™Âªte, filtres d'abord, puis order()
    var query = _sb.from('events').select('*');
    if (onlyPublished) {
      query = query.eq('status', 'published');
    }
    final dynamic resp = await query.order('start_at', ascending: true);

    final List data = (resp as List);
    return data.map((e) => Map<String, dynamic>.from(e as Map)).toList();
  }

  Future<List<Map<String, dynamic>>> fetchTicketTypes(String eventId) async {
    final dynamic resp =
        await _sb.from('ticket_types').select('*').eq('event_id', eventId);

    final List data = (resp as List);
    return data.map((e) => Map<String, dynamic>.from(e as Map)).toList();
  }

  Future<Map<String, dynamic>> createOrder({
    required String eventId,
    required List<Map<String, dynamic>>
        items, // {ticket_type_id, quantity, unit_cents}
    String devise = 'EUR',
  }) async {
    final uid = _requireUserId();

    final int totalCents = items.fold<int>(
      0,
      (sum, e) => sum + ((e['quantity'] as int) * (e['unit_cents'] as int)),
    );

    // 1) CrÃ©Â©Ã†â€™Â©er la commande (MOCK: status=paid ; en prod -> pending + webhook)
    final dynamic ordersResp = await _sb
        .from('orders')
        .insert({
          'buyer_id': uid,
          'total_cents': totalCents,
          'devise': devise,
          'status': 'paid',
          'payment_provider': 'mock',
        })
        .select()
        .limit(1);

    final List orders = (ordersResp as List);
    if (orders.isEmpty) {
      throw StateError(
          'CrÃ©Â©Ã†â€™Â©ation de commande Ã©Â©Ã†â€™Â©chouÃ©Â©Ã†â€™Â©e');
    }
    final Map<String, dynamic> order =
        Map<String, dynamic>.from(orders.first as Map);
    final String orderId = order['id'] as String;

    // 2) Lignes de commande
    for (final item in items) {
      await _sb.from('order_items').insert({
        'order_id': orderId,
        'ticket_type_id': item['ticket_type_id'],
        'quantity': item['quantity'],
        'unit_cents': item['unit_cents'],
      });
    }

    // 3) GÃ©Â©Ã†â€™Â©nÃ©Â©Ã†â€™Â©rer les tickets
    await _sb.rpc('issue_tickets_from_order', params: {'p_order_id': orderId});

    return order;
  }

  Future<List<Map<String, dynamic>>> fetchMyTickets() async {
    final uid = _requireUserId();
    final dynamic resp = await _sb
        .from('tickets')
        .select('*, events(titre, start_at, lieu), ticket_types(nom)')
        .eq('buyer_id', uid)
        .order('issued_at', ascending: false);

    final List data = (resp as List);
    return data.map((e) => Map<String, dynamic>.from(e as Map)).toList();
  }

  Future<Map<String, dynamic>> scanTicket(String qrCode) async {
    final dynamic resp = await _sb.rpc('use_ticket', params: {'qr': qrCode});
    if (resp == null) return {'ok': false, 'reason': 'NO_RESPONSE'};
    if (resp is Map) return Map<String, dynamic>.from(resp as Map);
    return {
      'ok': false,
      'reason': 'UNEXPECTED_RESPONSE',
      'data': resp.toString()
    };
  }
}
